#!/bin/bash

# License {{
_SD_CL_LICENSE='The MIT License (MIT)

Copyright (c) 2018 rcmdnk

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.'
# }}}

# Fixed Parameters {{{
_SD_CL_ERROR_NO_SUCH_DIRECTORY=10
_SD_CL_ERROR_NO_SAVED_DIRECTORY=11
_SD_CL_ERROR_NOT_STORED=12
_SD_CL_ERROR_INVALID_N=13
_SD_CL_ERROR_INVALID_INPUT=14
# }}}

# Parameters {{{
# Selection tool
export SD_CL_TOOL=${SD_CL_TOOL:-sentaku}

# Number of kept last directories
export SD_CL_N=${SD_CL_N:-20}

# Directory store file
export SD_CL_LASTDIR_FILE=${SD_CL_LASTDIR_FILE:-$HOME/.lastDir}
export SD_CL_PREDEF_FILE=${SD_CL_PREDEF_FILE:-$HOME/.predefDir}
export SD_CL_WINDOW_FILE=${SD_CL_WINDOW_FILE:-$HOME/.windowDir}
export SD_CL_RANKING_FILE=${SD_CL_RANKING_FILE:-$HOME/.rankingDir}

# post cd (overwrite cd (Bash) or chpwd (Zsh))
export SD_CL_ISPOSTCD=${SD_CL_ISPOSTCD:-1}

# COMPLETION
export SD_CL_NOCOMPLETION=${SD_CL_NOCOMPLETION:-0}
export SD_CL_NOCOMPINIT=${SD_CL_NOCOMPINIT:-0}

# cd wrap to pushd/popd
export SD_CL_ISCDWRAP=${SD_CL_ISCDWRAP:-1}

# Ranking method
export SD_CL_RANKING=${SD_CL_RANKING:-1}

# }}}

# main functions {{{

sd () {
  # Help
  local help="
  Usage: sd [-ecpwrCLh] [directory]

  If neither '-e' nor '-C' is specified, 'directory' (or current directory if 'directory' is not given)
  is stored in the list.

  Arguments:
     -e          Edit directory list file
     -C          Clear directories
     -c          Use the last directory file ($SD_CL_LASTDIR_FILE, default)
     -p          Use the pre-defiend dirctory file ($SD_CL_PREDEF_FILE)
     -w          Use the window dirctory file ($SD_CL_WINDOW_FILE)
     -r          Use the ranking directory file ($SD_CL_RANKING_FILE)
     -L          Print license and quit
     -h          Print this HELP and quit
"

  # Variables
  local edit=0
  local cleardir=0
  local file=${SD_CL_LASTDIR_FILE}
  local dir=""

  # Get arguments
  while [ $# -gt 0 ];do
    case $1 in
      "-e" ) edit=1;;
      "-c" ) file=${SD_CL_LASTDIR_FILE};mode="lastdir";;
      "-p" ) file=${SD_CL_PREDEF_FILE};mode="predef";;
      "-w" ) file=${SD_CL_WINDOW_FILE};mode="window";;
      "-r" ) file=${SD_CL_RANKING_FILE};mode="ranking";;
      "-C" ) cleardir=1;;
      "-L" ) echo "$_SD_CL_LICENSE"; return;;
      "-h" )
        echo "$help"|${PAGER:-less} >/dev/tty
        return
        ;;
      "--" ) shift; dir="$*"; break;;
      * ) dir="$*" ;;
    esac
    shift
  done

  # Edit predefined dir
  if [ $edit -eq 1 ];then
    ${EDITOR:-"vi"} "$file"
    return
  fi

  # Clear
  if [ $cleardir -eq 1 ];then
    : > "$file"
    return
  fi

  # Set Save Dir
  if [ "$dir" = "" ];then
    # Current directory
    dir=$(pwd)
    dir=${dir/^$HOME/\~/}
  fi

  if [ ! -d "${curdir/\~/$HOME}" ];then
    echo "$curdir: No such a directory"
    return $_SD_CL_ERROR_NO_SUCH_DIRECTORY
  else
    touch "$file"
    local pre_list="$(grep -v "^${curdir}$" < "$file"|head -n"$((SD_CL_N-1))")"
    echo "$curdir" > "$file"
    echo "$pre_list" >> "$file"
  fi
}

cl () {
  # Change to the last dir
  if [ $# -eq 0 ];then
    touch "${SD_CL_LASTDIR_FILE}"
    local ld="$(head -n1 "${SD_CL_LASTDIR_FILE}")"
    if [ "$ld" != "" ];then
      eval command cd "$ld" # eval to expand ~
      return
    else
      echo "There is no saved directory."
      return $_SD_CL_ERROR_NO_SAVED_DIRECTORY
    fi
  fi

  # Set selection tool
  local selection=""
  if type "$SD_CL_TOOL" >& /dev/null ;then
    selection=$SD_CL_TOOL
  elif [ "$SD_CL_TOOL" != "NONE" ];then
    local tool
    for tool in sentaku peco percol fzf fzy selecta gof pick;do
      if type $tool >& /dev/null ;then
        selection=$tool
        break
      fi
    done
  fi
  if [ $selection = "sentaku" ];then
    selection="sentaku -s line"
  fi

  # Help
  local help="
  Usage: cl [-lcCpwrbvLh] [-n <number> ] [<number>] [<directory>]
  If there are no arguments, you will move to the last saved directory by sd command.
  If you give any directory name, it searches for it in saved directories
  and cd to there if only one is found.
  If more than one directories are found, go to the selection mode.

  Arguments:
     -l          Show saved directories
     -c          Show saved directories and choose a directory
     -C          Clear directories
     <number>    Move to <number>-th last directory
     -n <number> Move to <number>-th last directory
     -p          Move to pre-defiend dirctory in $SD_CL_PREDEF_FILE
     -w          Move to other window's (screen/tmux) dirctory in $SD_CL_WINDOW_FILE
     -r          Move to ranking directory in $SD_CL_RANKING_FILE
     -b          Move back to moving histories
     -v          Move from current directory, like Vim
     -L          Print license and quit
     -h          Print this HELP and quit
"

  # Variables
  local list=0
  local mode="lastdir"
  local cleardir=0
  local n=""
  local dir=""
  local dirs=()
  local file=${SD_CL_LASTDIR_FILE}

  # Get arguments
  while [ $# -gt 0 ];do
    case $1 in
      "-l" ) list=1;;
      "-c" ) file=${SD_CL_LASTDIR_FILE};mode="lastdir";;
      "-n" ) n="$2"; shift;;
      "-p" ) file=${SD_CL_PREDEF_FILE};mode="predef";;
      "-w" ) file=${SD_CL_WINDOW_FILE};mode="window";;
      "-r" ) file=${SD_CL_RANKING_FILE};mode="ranking";;
      "-v" ) file="";mode="vim";;
      "-b" ) file="";mode="back";;
      "-C" ) cleardir=1;;
      "-L" ) echo "$SD_CL_LICENSE"; return;;
      "-h" )
        echo "$help"|${PAGER:-less} >/dev/tty
        return
        ;;
      "--" ) shift; dir="$*"; break;;
      * )
        if expr "$1" : "[0-9]*" >/dev/null;then
          n=$1
        else
          dir="$*"
          break
        fi
        ;;
    esac
    shift
  done

  # Clear
  if [ $cleardir -eq 1 ];then
    if [ "$file" != "" ];then
      : > "$file"
    elif [ $mode = "back" ];then
      dirs -c
    fi
    return
  fi

  # Set dirs
  # Functions for vim mode
  if [ -n "$file" ];then
    _cl_get_dirs () {
      local i=0
      local d
      while read -r d;do
        dirs=("${dirs[@]}" "$d")
      done < $file
    }
  elif [ $mode = vim ];then
    _cl_get_dirs () {
      # Get variables
      local orig_ifs=$IFS
      IFS=$'\n'
      for d in $(ls -a);do
        if [ "$d" = "." ];then
          continue
        elif [ ! -d "$d" ];then
          continue
        fi
        dirs=("${dirs[@]}" "$d")
      done
      IFS=$orig_ifs
    }
  elif [ $mode = back ];then
    _cl_get_dirs () {
      # Get variables
      local orig_ifs=$IFS
      IFS=$'\n'
      dirs=($(dirs -p))
      IFS=$orig_ifs
    }
  fi
  _cl_get_dirs

  # Check dirs
  if [ "${#dirs[@]}" -eq 0 ];then
    echo "No directory is stored for $mode"
    return
  fi

  # List up
  if [ $list -eq 1 ];then
    local d
    local i=0
    for d in "${dirs[@]}";do
      printf "%3d %s\\n" $i "${d/^$HOME/\~}"
      ((i++))
    done
    return
  fi

  # Change to given directory
  if [ "$dir" != "" ];then
    local d
    local dirs_tmp=()
    for d in "${dirs[@]}";do
      if echo "$d" |grep -q "$dir";then
        dirs_tmp=("${dirs_tmp[@]}" "$d")
      fi
    done
    dirs=()
    for d in "${dirs_tmp[@]}";do
      dirs=("${dirs[@]}" "$d")
    done
    if [ "${#dirs[@]}" -eq 0 ];then
      echo "No such a directory is stored for $mode: ${dir}"
      return $_SD_CL_ERROR_NOT_STORED
    fi
  fi

  if [ "$n" != "" ];then
    if ! expr "$n" : '[0-9]*' >/dev/null || [ "$n" -ge "${#dirs[@]}" ];then
      echo "$n is not valid."
      echo "Enter [0-$((${#dirs[@]}-1))]"
      return $_SD_CL_ERROR_INVALID_N
    fi
    dirs=("${dirs[$n]}")
  fi

  if [ "${#dirs[@]}" -eq 1 ];then
    dir="${dirs[0]}"
  else
     while :;do
       if [ -n "$selection" ];then
         dir=$(for d in "${dirs[@]}";do echo "$d";done|$selection)
       else
         local d
         local i=$((${#dirs[@]}-1))
         while [ $i -ge 0 ];do
           printf "%3d: %s\\n" $i "${dirs[$i]}"
           ((i--))
         done
         printf "\\nChoose directory number: "
         read -r i
         if ! expr "$i" : '[0-9]*' >/dev/null || [ "$i" -ge "${#dirs[@]}" ];then
           echo "$i is not valid."
           echo "Enter [0-$((${#dirs[@]}-1))]"
           return $_SD_CL_ERROR_INVALID_INPUT
         fi
         dir=${dirs[$i]}
       fi
       if [ -z "$dir" ];then
         return
       fi

       if [ $mode = vim ];then
         eval command cd "${dir}"
         dirs=()
         _cl_get_dirs
       else
         break
       fi
     done
  fi

  if [ $mode = back ];then
    local i
    i=$(dirs -p -v|grep " $dir$"|head -n1|awk '{print $1}')
    command pushd +"${i}" >/dev/null
    return
  fi

  if [ $mode = window ];then
    dir=$(echo $dir|awk  '{for(i=3;i<NF;++i){printf("%s ", $i)}print $NF}')
  elif [ $mode = ranking ];then
    dir=$(echo $dir|awk  '{for(i=2;i<NF;++i){printf("%s ", $i)}print $NF}')
  fi
  eval command cd "${dir}"
} # }}}

# Completion {{{
if [ $SD_CL_NOCOMPLETION -eq 0 ];then
  if [ "$ZSH_VERSION" != "" ];then
    if [ $SD_CL_NOCOMPINIT -eq 0 ];then
      autoload -Uz compinit
      compinit
    fi

    _cl () { # {{{
      typeset -A opt_args
      local context state line
      _arguments \
        '-l:: :->non'\
        '-c:: :->lastdir'\
        '-C:: :->non'\
        '-n:: :->xxx'\
        '-N:: :->xxx'\
        '-p:: :->predef'\
        '-w:: :->window'\
        '-r:: :->ranking'\
        '-b:: :->back'\
        '-v:: :->non'\
        '-h:: :->non'
      local ldf=""
      if echo "$state"|grep -q non;then
        return
      elif echo "$state"|grep -q predef;then
        ldf=${SD_CL_PREDEF_FILE}
      elif echo "$state"|grep -q window;then
        ldf=${SD_CL_WINDOW_FILE}
      elif echo "$state"|grep -q ranking;then
        ldf=${SD_CL_RANKING_FILE}
      elif echo "$state"|grep -q back;then
        :
      elif echo "$state"|grep -q lastdir;then
        ldf=${SD_CL_LASTDIR_FILE}
      else
        ldf=all
      fi
      local orig_ifs=$IFS
      IFS=$'\n'
      if [ "$ldf" = "all" ];then
        ldf=${SD_CL_LASTDIR_FILE}
        local pdf=${SD_CL_PREDEF_FILE}
        touch "$ldf"
        touch "$pdf"
        compadd $(cat "$ldf"|sed "s|~|$HOME|")
        compadd $(cat "$pdf"|sed "s|~|$HOME|")
        compadd $(dirs -p|sed "s|~|$HOME|")
      elif [ "$ldf" != "" ];then
        if echo "$state"|grep -q window;then
          compadd $(cat $ldf|cut -d' ' -f 3-|sed "s|~|$HOME|")
        elif echo "$state"|grep -q ranking;then
          compadd $(cat $ldf|cut -d' ' -f 2-|sed "s|~|$HOME|")
        else
          compadd $(cat $ldf|sed "s|~|$HOME|")
        fi
      else
        compadd $(dirs -p|sed "s|~|$HOME|")
      fi
      IFS=$orig_ifs
    }
    compdef _cl cl
    # }}}
    _bd () { # {{{
      typeset -A opt_args
      local orig_ifs=$IFS
      IFS=$'\n'
      compadd "$(dirs -p)"
      IFS=$orig_ifs
    }
    compdef _bd bd
    # }}}
  elif [ "$BASH_VERSION" != "" ];then
    _cl () { # {{{
      COMPREPLY=()
      local cur=${COMP_WORDS[COMP_CWORD]}
      local prev=${COMP_WORDS[COMP_CWORD-1]}
      local -a opts
      local -a opts_nocomp
      opts=(-l -c -C -n -N -p -w -b -v -h)
      opts_nocomp=(-l -C -v -h)
      local nocomp=0
      local i
      for i in $(seq 1 $((COMP_CWORD)));do
        if [ "${COMP_WORDS[$i]}" = "" ] || [ "${COMP_WORDS[$i]}" = "-" ];then
          continue
        fi
        if echo "${opts[@]}"|grep -q -- "${COMP_WORDS[$i]}";then
          opts=($(echo "${opts[@]}"|sed "s/${COMP_WORDS[$i]}//"))
          if echo "${opts_nocomp[@]}"|grep -q -- "${COMP_WORDS[$i]}";then
            nocomp=1
          fi
        fi
      done

      if [[ "$cur" == -* ]];then
        COMPREPLY=($( compgen -W "${opts[*]}" -- "$cur"))
        return
      elif [ "${COMP_WORDS[$i]}" != "" ] && echo "${opts[@]}"|grep -q "$cur";then
        COMPREPLY=("$cur")
        return
      elif [ $nocomp -eq 1 ];then
        return
      elif [[ "$prev" != -* && $COMP_CWORD -ne 1 ]];then
        return
      fi

      local ldf=${SD_CL_LASTDIR_FILE}
      local pdf=${SD_CL_PREDEF_FILE}
      local wdf=${SD_CL_WINDOW_FILE}
      local rdf=${SD_CL_RANKING_FILE}
      local d=""

      local orig_ifs=$IFS
      IFS=$'\n'
      case $prev in
        -c)touch "$ldf" && d=$(cat "$ldf"|sed "s|~|$HOME|");;
        -p)touch "$pdf" && d=$(cat "$pdf"|sed "s|~|$HOME|");;
        -w)touch "$ldf" && d=$(cat "$wdf"|cut -d' ' -f3-|sed "s|~|$HOME|");;
        -r)touch "$rdf" && d=$(cat "$rdf"|cut -d' ' -f2-|sed "s|~|$HOME|");;
        -b)d=$(dirs -p|sed "s|~|$HOME|");;
        *)
          touch "$ldf" && touch "$pdf" && d=$(cat "$ldf"|sed "s|~|$HOME|")$'\n'$(cat "$pdf"|sed "s|~|$HOME|")$'\n'$(dirs -p|sed "s|~|$HOME|")
          ;;
      esac
      COMPREPLY=($(echo "$d"|grep "$cur"))
      IFS=$orig_ifs
    }
    complete -F _cl cl
    # }}}
    _bd () { # {{{
      local orig_ifs=$IFS
      local cur=${COMP_WORDS[COMP_CWORD]}
      IFS=$'\n'
      COMPREPLY=($( compgen -W "$(dirs -p)" -- "$cur"))
      IFS=$orig_ifs
    }
    complete -F _bd bd
    # }}}
  fi
fi
# }}}

# ranking {{{
_cd_ranking () {
  local curdir=$(pwd)
  if [ "$curdir" = "$HOME" ];then
    return
  fi
  curdir=${curdir/^$HOME/\~}
  local rdf=${SD_CL_RANKING_FILE:-$HOME/.rankingDir}
  touch "$rdf"
  local i=$(grep " ${curdir}$" "$rdf"|cut -d" " -f1)
  if [ -z "$i" ];then
    echo "1 $curdir" >> "$rdf"
  else
    local rd=$(sed "s|${n} ${curdir}$|$((n+1)) ${curdir}|" "${rdf}"|sort -rn)
    echo "$rd" > "${rdf}"
  fi
}

if [ "$SD_CL_RANKING" -eq 2 ];then
  PROMPT_COMMAND="${PROMPT_COMMAND:+${PROMPT_COMMAND};}_cd_ranking"
fi
# }}}

# function for post cd {{{
_post_cd () {
  if [ "$SD_CL_RANKING" -eq 1 ];then
    _cd_ranking
  fi
  if [ -z "$STY" ] && [ -z "$TMUX" ];then
    return
  fi
  if [ -n "$STY" ];then
    local window="$WINDOW"
    local pane=0
  else
    local window="$(tmux display -p '#I')"
    local pane="$(tmux display -p '#P')"
  fi
  local wdf=${SD_CL_WINDOW_FILE}
  touch "$wdf"
  local d="$(pwd)"
  d="${d/^$HOME\~}"
  if grep -q "^$window $pane " "$wdf";then
    local wd=$(sed "s|^$window $pane .*$|$window $pane $d|" "$wdf"|sort -n)
  else
    local wd=$(cat "$wdf" && echo "$window $pane $d"|sort -n)
  fi
  echo "$wd" > "${wdf}"
}
# }}}

# function for cd wrap to pushd/popd {{{
_wrap_cd () {
  local dir="$*"
  if [ "$*" = "" ];then
    if [ "$(pwd)" = "$HOME" ];then
      return
    else
      dir="$HOME"
    fi
  elif [ "$*" = "-" ];then
    pushd >/dev/null
    return
  else
    if [ -f "$*" ];then
      dir=$(dirname "$*")
    fi
  fi
  pushd "$dir" >/dev/null
}

# Alias for popd
bd () {
  if [ $# -eq 0 ];then
    # 0 is current directory
    cl -b 1
  else
    cl -b "$*"
  fi
}
# }}}

# Set cd/chpwd {{{
if [ "$ZSH_VERSION" != "" ];then
  if [ "$SD_CL_ISPOSTCD" -eq 1 ];then
    chpwd () {
      _post_cd
    }
  fi
  if [ "$SD_CL_ISCDWRAP" -eq 1 ];then
    cd () {
      _wrap_cd "$*"
    }
  fi
else
  if [ "$SD_CL_ISPOSTCD" -eq 1 ] && [ "$SD_CL_ISCDWRAP" -eq 1 ];then
    cd () {
      _wrap_cd "$*"
      local ret=$?
      if [ $ret -eq 0 ];then
        _post_cd
      fi
      return $ret
    }
  elif [ "$SD_CL_ISPOSTCD" -eq 1 ];then
    cd () {
      builtin cd "$*"
      local ret=$?
      if [ $ret -eq 0 ];then
        _post_cd
      fi
      return $ret
    }
  elif [ "$SD_CL_ISCDWRAP" -eq 1 ];then
    cd () {
      _wrap_cd "$*"
    }
  fi
fi
# }}}

# Move to actual pwd {{{
cdpwd () {
  command cd "$(pwd -P)"
}
# }}}
