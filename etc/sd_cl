#!/bin/bash

# License {{
_SD_CL_LICENSE='The MIT License (MIT)

Copyright (c) 2018 rcmdnk

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.'
# }}}

# Fixed Parameters {{{
_SD_CL_ERROR_INVALID_ARGUMENT=100
_SD_CL_ERROR_IS_A_FILE=10
_SD_CL_ERROR_NO_SUCH_DIRECTORY=11
_SD_CL_ERROR_NO_SAVED_DIRECTORY=12
_SD_CL_ERROR_NOT_STORED=13
_SD_CL_ERROR_INVALID_N=14
_SD_CL_ERROR_INVALID_INPUT=15
# }}}

# Parameters {{{
# Selection tool
SD_CL_TOOL=${SD_CL_TOOL:-sentaku}

# Number of kept last directories (for SD_CL_LASTDIR_FILE)
SD_CL_N=${SD_CL_N:-20}

# Show window/pane or ranking information at selection
SD_CL_SHOW_MORE_INFO=${SD_CL_SHOW_MORE_INFO:-0}

# Directory store file
SD_CL_CONFIG_DIR=${SD_CL_CONFIG_DIR:-$HOME/.config/sd_cl}
SD_CL_LASTDIR_FILE=${SD_CL_LASTDIR_FILE:-${SD_CL_CONFIG_DIR}/lastdir}
SD_CL_PREDEF_FILE=${SD_CL_PREDEF_FILE:-${SD_CL_CONFIG_DIR}/predef}
SD_CL_WINDOW_FILE=${SD_CL_WINDOW_FILE:-${SD_CL_CONFIG_DIR}/window}
SD_CL_RANKING_FILE=${SD_CL_RANKING_FILE:-${SD_CL_CONFIG_DIR}/ranking}

# Ranking method
SD_CL_RANKING_METHOD=${SD_CL_RANKING_METHOD:-2}
SD_CL_RANKING_TRIAL_FILE=${SD_CL_RANKING_TRIAL_FILE:-${SD_CL_CONFIG_DIR}/ranking_trial}
SD_CL_RANKING_N_CD=${SD_CL_RANKING_N_CD:-100}
SD_CL_RANKING_N_CMD=${SD_CL_RANKING_N_CMD:-1000}
SD_CL_RANKING_EXCLUDE=${SD_CL_RANKING_EXCLUDE:-"$HOME"}

# post cd (overwrite cd (Bash) or chpwd (Zsh))
SD_CL_ISPOSTCD=${SD_CL_ISPOSTCD:-1}

# COMPLETION
SD_CL_NOCOMPLETION=${SD_CL_NOCOMPLETION:-0}
SD_CL_NOCOMPINIT=${SD_CL_NOCOMPINIT:-0}

# cd wrap to pushd/popd
SD_CL_ISCDWRAP=${SD_CL_ISCDWRAP:-1}
# }}}

# Other variables {{{
_SD_CL_BACK_HISTORY=()
# }}}


# support functions {{{
_sd_cl_cd () {
  _SD_CL_BACK_HISTORY=()
  eval builtin cd "$1"
}

_sd_cl_check_file () {
  mkdir -p "$(dirname "${1}")"
  touch "$1"
}

_sd_cl_reset_file () {
  mkdir -p "$(dirname "${1}")"
  : > "$file"
}

_sd_cl_edit_file () {
  if [ -n "$1" ];then
    _sd_cl_check_file "$1"
    ${EDITOR:-"vi"} "$1"
  fi
}

_sd_cl_get_dir () {
  if [ $# -ge 1 ];then
    local dir="$1"
  else
    local dir="$(pwd)"
  fi
  echo "$(echo "$dir"|sed "s|^$HOME|~|")"
}

_sd_cl_check_dir () {
  eval test -d "$1" && return
  if eval test -f "$1";then
    echo "$1 is a file"
    return $_SD_CL_ERROR_IS_A_FILE
  else
    echo "$1: No such a directory"
    return $_SD_CL_ERROR_NO_SUCH_DIRECTORY
  fi
}

_sd_cl_set_ksharray () {
  if [ -n "$ZSH_VERSION" ];then
    if ! setopt|grep -q ksharrays;then
      _SD_CL_KSHARRAY=1
      setopt ksharrays
    else
      _SD_CL_KSHARRAY=0
    fi
  fi
}

_sd_cl_reset_ksharray () {
  if [ -n "$ZSH_VERSION" ];then
    if [ $_SD_CL_KSHARRAY -eq 1 ];then
      unsetopt ksharrays
    fi
  fi
}

_sd_cl_get_n () {
  local n=$1
  if [ -n "$n" ];then
    shift
    ((n++))
    eval echo \$${n}
  fi
}

# }}}

# main functions {{{
sd () {
  # Help
  local help="
  Usage: sd [-ecpwrCLh] [directory]

  If neither '-e' nor '-C' is specified, 'directory' (or current directory if 'directory' is not given)
  is stored in the list.

  Arguments:
     -e          Edit directory list file
     -C          Clear directories
     -c          Use the last directory file ($SD_CL_LASTDIR_FILE, default)
     -p          Use the pre-defiend dirctory file ($SD_CL_PREDEF_FILE)
     -w          Use the window dirctory file ($SD_CL_WINDOW_FILE)
     -r          Use the ranking directory file ($SD_CL_RANKING_FILE)
     -L          Print license and quit
     -h          Print this HELP and quit
"

  # Variables
  local edit=0
  local cleardir=0
  local file=${SD_CL_LASTDIR_FILE}
  local dir=""

  # Get arguments
  while [ $# -gt 0 ];do
    case $1 in
      "-e" ) edit=1;;
      "-c" ) file=${SD_CL_LASTDIR_FILE};;
      "-p" ) file=${SD_CL_PREDEF_FILE};;
      "-C" ) cleardir=1;;
      "-L" ) echo "$_SD_CL_LICENSE"; return;;
      "-h" )
        echo "$help"
        return
        ;;
      "--" ) shift; dir="$*"; break;;
      -* )
        echo "Invalid argument: $1"
        return $_SD_CL_ERROR_INVALID_ARGUMENT
        ;;
      * ) dir="$*" ;;
    esac
    shift
  done

  # Edit predefined dir
  if [ "$edit" -eq 1 ];then
    _sd_cl_edit_file "$file"
    return
  fi

  # Clear
  if [ "$cleardir" -eq 1 ];then
    _sd_cl_reset_file "$file"
    return
  fi

  # Set Save Dir
  if [ -z "$dir" ];then
    # Current directory
    dir=$(_sd_cl_get_dir)
  fi

  if ! _sd_cl_check_dir "$dir";then
    return $?
  else
    _sd_cl_check_file "$file"
    local pre_list="$(grep -v "^${dir}$" < "$file"|grep -v '^\s*$'|head -n"$((SD_CL_N-1))")"
    echo "$dir" > "$file"
    if [ -n "$pre_list" ];then
      echo "$pre_list" >> "$file"
    fi
  fi
}

cl () {
  # Set default file
  local file="${SD_CL_LASTDIR_FILE}"

  # Change to the last dir
  if [ $# -eq 0 ];then
    _sd_cl_check_file "$file"
    local ld="$(head -n1 "${SD_CL_LASTDIR_FILE}")"
    if [ -n "$ld" ];then
      _sd_cl_cd "$ld"
      return
    else
      echo "There is no saved directory."
      return $_SD_CL_ERROR_NO_SAVED_DIRECTORY
    fi
  fi

  # Help
  local help="
  Usage: cl [-lecCpwrbvLh] [-n <number> ] [<number>] [<directory>]
  If there are no arguments, you will move to the last saved directory by sd command.
  If you give any directory name, it searches for it in saved directories
  and cd to there if only one is found.
  If more than one directories are found, go to the selection mode.

  Arguments:
     -l          Show saved directories
     -e          Edit directory list file
     -c          Show saved directories and choose a directory
     -C          Clear directories
     <number>    Move to <number>-th last directory
     -n <number> Move to <number>-th last directory
     -p          Move to pre-defiend dirctory in $SD_CL_PREDEF_FILE
     -w          Move to other window's (screen/tmux) dirctory in $SD_CL_WINDOW_FILE
     -r          Move to ranking directory in $SD_CL_RANKING_FILE
     -b          Move back to moving histories
     -v          Move from current directory, like Vim
     -L          Print license and quit
     -h          Print this HELP and quit
"

  # Variables
  local list=0
  local edit=0
  local mode="lastdir"
  local cleardir=0
  local n=""
  local dir=""
  local dirs=()

  # Get arguments
  while [ $# -gt 0 ];do
    case $1 in
      "-l" ) list=1;;
      "-e" ) edit=1;;
      "-c" ) file=${SD_CL_LASTDIR_FILE};mode="lastdir";;
      "-n" ) n="$2"; shift;;
      "-p" ) file=${SD_CL_PREDEF_FILE};mode="predef";;
      "-w" ) file=${SD_CL_WINDOW_FILE};mode="window";;
      "-r" ) file=${SD_CL_RANKING_FILE};mode="ranking";;
      "-v" ) file="";mode="vim";;
      "-b" ) file="";mode="back";;
      "-C" ) cleardir=1;;
      "-L" ) echo "$_SD_CL_LICENSE"; return;;
      "-h" )
        echo "$help"
        return
        ;;
      "--" ) shift; dir="$*"; break;;
      -* )
        echo "Invalid argument: $1"
        return $_SD_CL_ERROR_INVALID_ARGUMENT
        ;;
      * )
        if expr "$1" : "[0-9]*" >/dev/null;then
          n=$1
        else
          dir="$*"
          break
        fi
        ;;
    esac
    shift
  done

  # Clear
  if [ "$cleardir" -eq 1 ];then
    if [ -n "$file" ];then
      : > "$file"
    elif [ "$mode" = "back" ];then
      builtin dirs -c
    fi
    return
  fi

  # Edit
  if [ "$edit" -eq 1 ];then
    _sd_cl_edit_file "$file"
    return
  fi

  # Set get_dirs function
  if [ -n "$file" ];then
    if [ "$mode" = ranking ];then
      _sd_cl_ranking_update
    fi
    _cl_get_dirs () {
      local i=0
      local d
      _sd_cl_check_file "$file"
      while read -r d;do
        dirs=("${dirs[@]}" "$d")
      done < "$file"
    }
  elif [ "$mode" = vim ];then
    _cl_get_dirs () {
      # Get variables
      for d in *;do
        if [ ! -d "$d" ];then
          continue
        fi
        dirs=("${dirs[@]}" "$d")
      done
      dirs=(".." "${dirs[@]}")
    }
  elif [ "$mode" = back ];then
    _cl_get_dirs () {
      # Get variables
      local orig_ifs=$IFS
      IFS=$'\n'
      dirs=($(builtin dirs -p))
      IFS=$orig_ifs
    }
  fi
  _cl_get_dirs

  # Check dirs
  if [ "${#dirs[@]}" -eq 0 ];then
    echo "No directory is stored for $mode"
    return
  fi

  # List up
  if [ "$list" -eq 1 ];then
    local d
    local i=0
    for d in "${dirs[@]}";do
      printf "%3d %s\\n" $i "$(_sd_cl_get_dir "${d}")"
      ((i++))
    done
    return 0
  fi

  # Cleanup list
  local dirs_tmp=()
  local d
  for d in "${dirs[@]}";do
    if [ "$SD_CL_SHOW_MORE_INFO" -eq 0 ];then
      if [ "$mode" = window ];then
        d=$(echo "$d"|awk  '{for(i=3;i<NF;++i){printf("%s ", $i)}print $NF}')
      elif [ "$mode" = ranking ];then
        d=$(echo "$d"|awk  '{for(i=2;i<NF;++i){printf("%s ", $i)}print $NF}')
      fi
    fi
    if [ -n "$dir" ];then
      if ! eval echo "$d" |eval grep -q -- "$dir";then
        continue
      fi
    fi
    dirs_tmp=("${dirs_tmp[@]}" "$d")
  done
  if [ "${#dirs_tmp[@]}" -eq 0 ];then
    echo "No such a directory is stored for $mode: ${dir}"
    return $_SD_CL_ERROR_NOT_STORED
  fi

  dirs=()
  for d in "${dirs_tmp[@]}";do
    dirs=("${dirs[@]}" "$d")
  done

  if [ -n "$n" ];then
    if ! expr "$n" : '[0-9]*' >/dev/null || [ "$n" -ge "${#dirs[@]}" ];then
      echo "$n is not valid number."
      echo "Enter [0-$((${#dirs[@]}-1))]"
      return $_SD_CL_ERROR_INVALID_N
    fi
    dirs=("$(_sd_cl_get_n "$n" "${dirs[@]}")")
  fi

  if [ "${#dirs[@]}" -eq 1 ] &&  [ "$mode" != vim ];then
    dir="$(_sd_cl_get_n 0 "${dirs[@]}")"
  else
    # Set selection tool
    local selection=""
    if type "$SD_CL_TOOL" >& /dev/null ;then
      selection=$SD_CL_TOOL
    elif [ "$SD_CL_TOOL" != "NONE" ] && [ "$SD_CL_TOOL" != "shell" ];then
      local tool
      for tool in sentaku peco percol fzf fzy selecta gof pick;do
        if type $tool >& /dev/null ;then
          selection=$tool
          break
        fi
      done
    fi
    if [ "$selection" = "sentaku" ];then
      selection="sentaku -s line"
    fi

    while :;do
      if [ -n "$selection" ];then
        dir=$(for d in "${dirs[@]}";do echo "$d";done|eval "$selection")
      else
        local d
        local i=$((${#dirs[@]}-1))
        while [ $i -ge 0 ];do
          printf "%3d: %s\\n" $i "$(_sd_cl_get_n $i "${dirs[@]}")"
          ((i--))
        done
        printf "\\nChoose directory number: "
        read -r i
        if [ -z "$i" ];then
          return
        fi
        if ! expr "$i" : '[0-9]*' >/dev/null || [ "$i" -ge "${#dirs[@]}" ];then
          echo "$i is not valid."
          echo "Enter [0-$((${#dirs[@]}-1))]"
          return $_SD_CL_ERROR_INVALID_INPUT
        fi
        dir="$(_sd_cl_get_n "$i" "${dirs[@]}")"
      fi
      if [ -z "$dir" ];then
        return
      fi

      if [ "$mode" = vim ];then
        _sd_cl_cd "$dir"
        dirs=()
        _cl_get_dirs
      else
        break
      fi
    done
  fi

  if [ "$mode" = back ];then
    local i
    i=$(builtin dirs -p -v|grep "[[:space:]]$dir$"|head -n1|awk '{print $1}')
    builtin pushd +"${i}" >/dev/null
    return
  fi

  if [ "$SD_CL_SHOW_MORE_INFO" -ne 0 ];then
    if [ "$mode" = window ];then
      dir=$(echo "$dir"|awk  '{for(i=3;i<NF;++i){printf("%s ", $i)}print $NF}')
    elif [ "$mode" = ranking ];then
      dir=$(echo "$dir"|awk  '{for(i=2;i<NF;++i){printf("%s ", $i)}print $NF}')
    fi
  fi

  _sd_cl_cd "$dir"
} # }}}

# Completion {{{
if [ "$SD_CL_NOCOMPLETION" -eq 0 ];then
  if [ -n "$ZSH_VERSION" ];then
    if [ "$SD_CL_NOCOMPINIT" -eq 0 ];then
      autoload -Uz compinit
      compinit
    fi

    _cl () { # {{{
      typeset -A opt_args
      local state line
      _arguments \
        '-l:: :->non'\
        '-c:: :->lastdir'\
        '-C:: :->non'\
        '-n:: :->xxx'\
        '-N:: :->xxx'\
        '-p:: :->predef'\
        '-w:: :->window'\
        '-r:: :->ranking'\
        '-b:: :->back'\
        '-v:: :->non'\
        '-h:: :->non'
      local ldf=""
      if echo "$state"|grep -q non;then
        return
      elif echo "$state"|grep -q predef;then
        ldf=${SD_CL_PREDEF_FILE}
      elif echo "$state"|grep -q window;then
        ldf=${SD_CL_WINDOW_FILE}
      elif echo "$state"|grep -q ranking;then
        ldf=${SD_CL_RANKING_FILE}
      elif echo "$state"|grep -q back;then
        :
      elif echo "$state"|grep -q lastdir;then
        ldf=${SD_CL_LASTDIR_FILE}
      else
        ldf=all
      fi
      local orig_ifs=$IFS
      IFS=$'\n'
      if [ "$ldf" = "all" ];then
        ldf=${SD_CL_LASTDIR_FILE}
        local pdf=${SD_CL_PREDEF_FILE}
        _sd_cl_check_file "$ldf"
        _sd_cl_check_file "$pdf"
        compadd $(cat "$ldf")
        compadd $(cat "$pdf")
        compadd $(builtin dirs -p)
      elif [ -n "$ldf" ];then
        if echo "$state"|grep -q window;then
          compadd $(cat $ldf|cut -d' ' -f 3-)
        elif echo "$state"|grep -q ranking;then
          compadd $(cat $ldf|cut -d' ' -f 2-)
        else
          compadd $(cat $ldf)
        fi
      else
        compadd $(builtin dirs -p)
      fi
      IFS=$orig_ifs
    }
    compdef _cl cl
    # }}}
    _bd () { # {{{
      typeset -A opt_args
      local orig_ifs=$IFS
      IFS=$'\n'
      compadd "$(builtin dirs -p)"
      IFS=$orig_ifs
    }
    compdef _bd bd
    # }}}
  elif [ -n "$BASH_VERSION" ];then
    _cl () { # {{{
      COMPREPLY=()
      local cur=${COMP_WORDS[COMP_CWORD]}
      local prev=${COMP_WORDS[COMP_CWORD-1]}
      local -a opts
      local -a opts_nocomp
      opts=(-l -c -C -n -N -p -w -b -v -h)
      opts_nocomp=(-l -C -v -h)
      local nocomp=0
      local i
      for i in $(seq 1 $((COMP_CWORD)));do
        if [ -z "${COMP_WORDS[$i]}" ] || [ "${COMP_WORDS[$i]}" = "-" ];then
          continue
        fi
        if echo "${opts[@]}"|grep -q -- "${COMP_WORDS[$i]}";then
          opts=($(echo "${opts[@]}"|sed "s/${COMP_WORDS[$i]}//"))
          if echo "${opts_nocomp[@]}"|grep -q -- "${COMP_WORDS[$i]}";then
            nocomp=1
          fi
        fi
      done

      if [[ "$cur" == -* ]];then
        COMPREPLY=($( compgen -W "${opts[*]}" -- "$cur"))
        return
      elif [ -n "${COMP_WORDS[$i]}" ] && echo "${opts[@]}"|grep -q -- "$cur";then
        COMPREPLY=("$cur")
        return
      elif [ $nocomp -eq 1 ];then
        return
      elif [[ "$prev" != -* && $COMP_CWORD -ne 1 ]];then
        return
      fi

      local ldf=${SD_CL_LASTDIR_FILE}
      local pdf=${SD_CL_PREDEF_FILE}
      local wdf=${SD_CL_WINDOW_FILE}
      local rdf=${SD_CL_RANKING_FILE}
      local d=""

      local orig_ifs=$IFS
      IFS=$'\n'
      case $prev in
        -c)_sd_cl_check_file "$ldf" && d=$(cat "$ldf");;
        -p)_sd_cl_check_file "$pdf" && d=$(cat "$pdf");;
        -w)_sd_cl_check_file "$ldf" && d=$(cat "$wdf"|cut -d' ' -f3-);;
        -r)_sd_cl_check_file "$rdf" && d=$(cat "$rdf"|cut -d' ' -f2-);;
        -b)d=$(builtin dirs -p);;
        *)
          _sd_cl_check_file "$ldf" && _sd_cl_check_file "$pdf" && d=$(cat "$ldf")$'\n'$(cat "$pdf")$'\n'$(builtin dirs -p)
          ;;
      esac
      COMPREPLY=($(echo "$d"|grep -- "$cur"))
      IFS=$orig_ifs
    }
    complete -F _cl cl
    # }}}
    _bd () { # {{{
      local orig_ifs=$IFS
      local cur=${COMP_WORDS[COMP_CWORD]}
      IFS=$'\n'
      COMPREPLY=($( compgen -W "$(builtin dirs -p)" -- "$cur"))
      IFS=$orig_ifs
    }
    complete -F _bd bd
    # }}}
  fi
fi
# }}}

# ranking {{{
_sd_cl_ranking_update () {
  _sd_cl_check_file "${SD_CL_RANKING_FILE}"
  _sd_cl_check_file "${SD_CL_RANKING_TRIAL_FILE}"
  local trial="$(cat "${SD_CL_RANKING_TRIAL_FILE}")"
  if ! expr "$trial" : "[0-9]*" >/dev/null;then
    trial=0
  fi
  local dirs=()
  local line
  while read -r line;do
    local rank="$(echo "$line"|cut -d' ' -f1)"
    local dir="$(echo "$line"|cut -d' ' -f2-)"
    if ! expr "$rank" : "[0-9]*" >/dev/null;then
      continue
    fi
    rank=$((rank-trial))
    if [ "$rank" -le 0 ];then
      continue
    fi
    dirs=("${dirs[@]}" "$rank $dir")
  done < "${SD_CL_RANKING_FILE}"
  for line in "${dirs[@]}";do
    echo "$line"
  done |sort -rn > "${SD_CL_RANKING_FILE}"

  echo 0 > "${SD_CL_RANKING_TRIAL_FILE}"
}

_sd_cl_ranking () {
  if [ -n "$SD_CL_RANKING_EXCLUDE" ];then
    local orig_ifs=$IFS
    IFS=","
    local exclude=($(echo "$SD_CL_RANKING_EXCLUDE"))
    IFS=$orig_ifs
    local dir
    local curdir="$(pwd)"
    for dir in "${exclude[@]}";do
      if [ "$curdir" = "$(eval echo "$dir")" ];then
        return
      fi
    done
  fi
  curdir=$(_sd_cl_get_dir)
  if [ "$SD_CL_RANKING_METHOD" -eq 2 ];then
    local n=${SD_CL_RANKING_N_CMD}
  else
    local n=${SD_CL_RANKING_N_CD}
  fi
  _sd_cl_check_file "${SD_CL_RANKING_FILE}"
  local rank=$(grep -- " ${curdir}$" "${SD_CL_RANKING_FILE}"|cut -d" " -f1)
  if [ -z "$rank" ];then
    echo "$n $curdir" >> "${SD_CL_RANKING_FILE}"
  else
    local rd=$(sed "s|${rank} ${curdir}$|$((rank+n)) ${curdir}|" "${SD_CL_RANKING_FILE}"|sort -rn)
    echo "$rd" > "${SD_CL_RANKING_FILE}"
  fi

  _sd_cl_check_file "${SD_CL_RANKING_TRIAL_FILE}"
  local trial="$(cat "${SD_CL_RANKING_TRIAL_FILE}")"
  if ! expr "$trial" : "[0-9]*" >/dev/null;then
    trial=1
  else
    ((trial++))
  fi
  echo $trial > "${SD_CL_RANKING_TRIAL_FILE}"
}

if [ "$SD_CL_RANKING_METHOD" -eq 2 ];then
  if ! echo "$PROMPT_COMMAND"|grep -q _sd_cl_ranking;then
    PROMPT_COMMAND="${PROMPT_COMMAND:+${PROMPT_COMMAND};}_sd_cl_ranking"
  fi
fi
# }}}

# function for post cd {{{
_post_cd () {
  if [ "$SD_CL_RANKING_METHOD" -eq 1 ];then
    _sd_cl_ranking
  fi
  if [ -z "$STY" ] && [ -z "$TMUX" ];then
    return
  fi
  if [ -n "$STY" ];then
    local win="$WINDOW"
    local pane=0
  else
    local win="$(tmux display -p '#I')"
    local pane="$(tmux display -p '#P')"
  fi
  local wdf=${SD_CL_WINDOW_FILE}
  _sd_cl_check_file "$wdf"
  local dir=$(_sd_cl_get_dir)
  if grep -q "^$win $pane " "$wdf";then
    local wd=$(sed "s|^$win $pane .*$|$win $pane $dir|" "$wdf"|sort -n)
  else
    local wd=$(cat "$wdf" && echo "$win $pane $dir"|sort -n)
  fi
  echo "$wd" > "${wdf}"
}
# }}}

# function for cd wrap to pushd/popd {{{
_wrap_cd () {
  local dir="$*"
  if [ -z "$*" ];then
    if [ "$(pwd)" = "$HOME" ];then
      return
    else
      dir="$HOME"
    fi
  elif [ "$*" = "-" ];then
    builtin pushd >/dev/null
    return
  else
    if [ -f "$*" ];then
      dir=$(dirname "$*")
    fi
  fi
  builtin pushd "$dir" >/dev/null
}

# go back/forward
bd () {
  if [ $# -eq 0 ];then
    if [ "$(pwd)" != "$(_sd_cl_get_n 0 "${_SD_CL_BACK_HISTORY[@]}")" ];then
      _SD_CL_BACK_HISTORY=("$(pwd)" "${_SD_CL_BACK_HISTORY[@]}")
    fi
    builtin popd >&/dev/null
  else
    cl -b "$*"
  fi
}

fd () {
  if [ $# -eq 0 ];then
    local n=1
  else
    local n=$1
  fi
  if [ "$n" -eq 0 ];then
    # Start from 1, as is bd
    return 1
  fi
  ((n--))
  if [ ${#_SD_CL_BACK_HISTORY[@]} -gt 0 ];then
    local dir=$(_sd_cl_get_n "$n" "${_SD_CL_BACK_HISTORY[@]}")
    local dirs_tmp=("${_SD_CL_BACK_HISTORY[@]}")
    _SD_CL_BACK_HISTORY=()
    local i=0
    for d in "${dirs_tmp[@]}";do
      ((i++))
      if [ "$((i-1))" -le "$n" ];then
        continue
      fi
      _SD_CL_BACK_HISTORY=("${_SD_CL_BACK_HISTORY[@]}" "$d")
    done
    builtin cd "$dir"
  else
    return 1
  fi
}
# }}}

# Set cd/chpwd {{{
if [ -n "$ZSH_VERSION" ];then
  if [ "$SD_CL_ISPOSTCD" -eq 1 ];then
    chpwd () {
      _post_cd
    }
  fi
  if [ "$SD_CL_ISCDWRAP" -eq 1 ];then
    cd () {
      _wrap_cd "$*"
    }
  fi
else
  if [ "$SD_CL_ISPOSTCD" -eq 1 ] && [ "$SD_CL_ISCDWRAP" -eq 1 ];then
    cd () {
      _wrap_cd "$*"
      local ret=$?
      if [ $ret -eq 0 ];then
        _post_cd
      fi
      return $ret
    }
  elif [ "$SD_CL_ISPOSTCD" -eq 1 ];then
    cd () {
      builtin cd "$*"
      local ret=$?
      if [ $ret -eq 0 ];then
        _post_cd
      fi
      return $ret
    }
  elif [ "$SD_CL_ISCDWRAP" -eq 1 ];then
    cd () {
      _wrap_cd "$*"
    }
  fi
fi
# }}}

# Move to actual pwd {{{
cdpwd () {
  _sd_cl_cd "$(pwd -P)"
}
# }}}
